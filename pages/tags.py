import streamlit as st
from sqlalchemy import text
import json
import ollama
import json
import concurrent.futures

def connect_db():
    try:
        @st.cache_resource
        def get_connection():
            return st.connection('mysql', type='sql')
        return get_connection()
    except Exception as e:
        st.error(f"Error connecting to MySQL: {e}")
        st.stop()

conn = connect_db()

UPLOAD_DIR = st.secrets["general"]["UPLOAD_DIR"]


    
# Predefined list of educational subjects
VALID_SUBJECTS = [
    "Mathematics", "Physics", "Chemistry", "Biology", "Computer Science",
    "History", "Geography", "Literature", "Economics", "Business Studies",
    "Political Science", "Sociology", "Psychology", "Engineering", "Medicine",
    "Education", "General Science", "Management", "Marketing", "Medical", "Self Help", 
    "Physical Education", "Commerce", "Law", "Social Science"
]




########################################################################################################################
##################################--------------- Tag test ----------------------------######################
#######################################################################################################################


# def generate_tags_with_ollama(book_title, model):
#     """Generate tags using the specified Ollama model and clean the output."""
#     try:
#         prompt = f"""
#         You are a book tagging assistant for a book management system. 
#         Based only on the given book title, generate only 3 to 4 concise and highly relevant tags. 

#         Rules:
#         - Tags must be single words or short phrases (max 2 words). 
#         - Do not add filler or generic tags like 'book', 'novel', 'story', 'interesting', 'popular'.
#         - Only return a comma-separated list with exactly 3 to 4 tags, no extra text.

#         Book Title: {book_title}

#         Example output: Social Security,AI,Machine Learning,Tourism,Management
#         """
#         # Measure start time
#         start_time = time.time()
        
#         response = ollama.generate(model=model, prompt=prompt)
#         raw_response = response['response'].strip()
        
#         # Calculate elapsed time
#         elapsed_time = time.time() - start_time
        
#         # Debug: Show raw response and elapsed time
#         st.write(f"Debug: Raw Ollama response (model: {model}): {raw_response}")
#         st.write(f"Time taken to generate tags: {elapsed_time:.2f} seconds")
        
#         # Clean the output to extract only comma-separated tags
#         if raw_response.startswith("here are the tags") or "*" in raw_response or "-" in raw_response:
#             # Extract tags from lines with bullets or after preamble
#             lines = raw_response.split("\n")
#             tags = []
#             for line in lines:
#                 line = line.strip()
#                 if line.startswith("*") or line.startswith("-"):
#                     tags.append(line.lstrip("*- ").strip())
#                 elif "," in line:
#                     tags.extend([tag.strip() for tag in line.split(",") if tag.strip()])
#         else:
#             tags = [tag.strip() for tag in raw_response.split(",") if tag.strip()]
        
#         # Ensure exactly 3 tags: trim or pad with fallbacks
#         tags = list(dict.fromkeys([tag.lower() for tag in tags if tag]))  # Remove duplicates and lowercase
#         if len(tags) > 5:
#             tags = tags[:4]  # Take first 4
#         elif len(tags) < 4:
#             # Fallback tags if insufficient
#             fallback_tags = ["general", "education", "literature"]
#             tags.extend(fallback_tags[:4 - len(tags)])  # Pad to exactly 3
        
#         if not tags:
#             st.warning(f"No valid tags generated by {model}.")
#             return [], elapsed_time
        
#         return tags, elapsed_time
#     except Exception as e:
#         st.error(f"Failed to generate tags with {model}: {str(e)}")
#         return [], 0.0  # Return empty tags and 0 time on error

# # Streamlit UI for testing
# st.write("#### Test Tag Generation")

# # Input for book title and model selection
# col1, col2 = st.columns([2, 1])
# book_title = col1.text_input("Book Title", placeholder="Enter Book Title (e.g., The History of Space Exploration)")
# model = col2.selectbox("Select Model", ["llama3.1:8b", "gemma3:1b", "smollm2:1.7b", "gemma3:4b"], index=1)

# if book_title:
#     with st.spinner(f"Generating tags with {model}..."):
#         tags, elapsed_time = generate_tags_with_ollama(book_title, model)
#         if tags:
#             st.write(f"**Tags to be saved**: {tags}")
#             st.write(f"**JSON format for database**: {json.dumps(tags)}")
#             st.write(f"**Generation time**: {elapsed_time:.2f} seconds")
#         else:
#             st.warning(f"No tags generated by {model}. Check the debug output above.")


# ########################################################################################################################
# ##################################--------------- Generate new tags for whole books ----------------------------######################
# #######################################################################################################################



# def generate_tags_with_ollama(book_title):
#     """Generate exactly 3 concise tags using the Ollama model."""
#     try:
#         prompt = f"""
#         You are a book tagging assistant for a book management system. 
#         Based only on the given book title, generate only 3 to 4 concise and highly relevant tags. 

#         Rules:
#         - Tags must be single words or short phrases (max 2 words). 
#         - Do not add filler or generic tags like 'book', 'novel', 'story', 'interesting', 'popular'.
#         - Only return a comma-separated list with exactly 3 to 4 tags, no extra text.

#         Book Title: {book_title}

#         Example output: Social Security,AI,Machine Learning,Tourism,Management
#         """
#         response = ollama.generate(model="llama3.1:8b", prompt=prompt)
#         raw_response = response['response'].strip()
        
#         # Debug: Log raw response to console and Streamlit
#         st.write(f"Raw Ollama response for '{book_title}': {raw_response}")
        
#         # Clean the output to extract only comma-separated tags
#         if raw_response.startswith("here are the tags") or "*" in raw_response or "-" in raw_response:
#             lines = raw_response.split("\n")
#             tags = []
#             for line in lines:
#                 line = line.strip()
#                 if line.startswith("*") or line.startswith("-"):
#                     tags.append(line.lstrip("*- ").strip())
#                 elif "," in line:
#                     tags.extend([tag.strip() for tag in line.split(",") if tag.strip()])
#         else:
#             tags = [tag.strip() for tag in raw_response.split(",") if tag.strip()]
        
#         # Ensure exactly 3 tags: trim or pad with fallbacks
#         tags = list(dict.fromkeys([tag.lower() for tag in tags if tag]))  # Remove duplicates and lowercase
#         if len(tags) > 4:
#             tags = tags[:4]  # Take first 3
#         elif len(tags) < 4:
#             # Fallback tags if insufficient
#             fallback_tags = ["general", "book", "literature"]
#             tags.extend(fallback_tags[:4 - len(tags)])  # Pad to exactly 3
        
#         if not tags:
#             st.warning(f"No valid tags generated for '{book_title}'. Using fallback tags.")
#             return ["general", "book", "literature"]
        
#         return tags
#     except Exception as e:
#         st.error(f"Error generating tags for '{book_title}': {str(e)}")
#         return ["general", "book", "literature"]  # Fallback on error

# def update_book_tags(conn):
#     """Fetch all books, generate 3 tags for each, and update the tags column."""
#     try:
#         with conn.session as s:
#             # Fetch all books (book_id and title)
#             result = s.execute(text("SELECT book_id, title FROM books")).fetchall()
#             if not result:
#                 st.warning("No books found in the database.")
#                 return 0, []
            
#             st.write(f"Found {len(result)} books to process.")
            
#             updated_count = 0
#             errors = []
#             progress_text = "Processing books and generating tags..."
#             progress_bar = st.progress(0, text=progress_text)
#             total_books = len(result)
            
#             for i, (book_id, book_title) in enumerate(result):
#                 if not book_title:
#                     st.warning(f"Skipping book ID {book_id}: No title provided.")
#                     errors.append(f"Book ID {book_id}: No title provided.")
#                     continue
                
#                 # Generate exactly 3 tags
#                 tags = generate_tags_with_ollama(book_title)
#                 tags_json = json.dumps(tags)
                
#                 # Update the tags column
#                 try:
#                     update_result = s.execute(
#                         text("UPDATE books SET tags = :tags WHERE book_id = :book_id"),
#                         {"tags": tags_json, "book_id": book_id}
#                     )
#                     s.commit()
#                     updated_count += update_result.rowcount
#                     st.write(f"Updated book ID {book_id} ('{book_title}'): Tags = {tags_json}")
#                 except Exception as db_error:
#                     st.error(f"Database error updating book ID {book_id} ('{book_title}'): {str(db_error)}")
#                     s.rollback()
#                     errors.append(f"Book ID {book_id} ('{book_title}'): {str(db_error)}")
#                     continue
                
#                 # Update progress bar
#                 progress_value = min((i + 1) / total_books, 1.0)
#                 progress_bar.progress(progress_value, text=progress_text)
            
#             # Clear progress bar
#             progress_bar.empty()
#             return updated_count, errors
    
#     except Exception as e:
#         st.error(f"Error accessing database session: {str(e)}")

#         return 0, [str(e)]

# # Streamlit UI
# st.write("#### Update Book Tags")


# # Connect to database
# conn = connect_db()


# # Button to trigger tag update
# if st.button("Generate and Save Tags"):
#     try:
#         # Test Ollama connection
#         ollama.generate(model="llama3.1:8b", prompt="test")
#         st.write("Ollama server is running.")
        
#         # Update tags
#         updated_count, errors = update_book_tags(conn)
        
#         if updated_count > 0:
#             st.success(f"Successfully updated tags for {updated_count} books.")
#         else:
#             st.warning("No books were updated.")
        
#         if errors:
#             st.error("Errors encountered during processing:")
#             for err in errors:
#                 st.write(err)
    
#     except Exception as e:
#         st.error(f"Error: Ollama server not running or inaccessible: {str(e)}")
#         st.markdown("Please start the Ollama server with `ollama serve` and ensure 'gemma3:1b' is installed.")


def generate_tags_with_ollama(book_title):
    """Generate 3 to 4 concise tags for a book title using the Ollama model."""
    try:
        prompt = f"""
        You are a book tagging assistant for a book management system. 
        Based only on the given book title, generate 4 concise and highly relevant tags. 

        Rules:
        - Tags must be single words or short phrases (max 2 words). 
        - Do not add filler or generic tags like 'book', 'novel', 'story', 'interesting', 'popular'.
        - Only return a comma-separated list of the tags and nothing else.

        Book Title: {book_title}

        Example output: Social Security, AI, Machine Learning, Management
        """
        response = ollama.generate(model="llama3.1:8b", prompt=prompt)
        raw_response = response['response'].strip()
        
        # This function can be called from a thread, so avoid st.write here.
        # print(f"Raw Ollama response for '{book_title}': {raw_response}")
        
        # Clean the output to extract tags
        if "here are the tags" in raw_response.lower() or "*" in raw_response or "-" in raw_response:
            lines = raw_response.split("\n")
            tags = []
            for line in lines:
                line = line.strip()
                if line.startswith("*") or line.startswith("-"):
                    tags.append(line.lstrip("*- ").strip())
                elif "," in line: # Check for comma-separated tags in any line
                    tags.extend([tag.strip() for tag in line.split(",") if tag.strip()])
        else:
            # Assume it's a simple comma-separated list
            tags = [tag.strip() for tag in raw_response.split(",") if tag.strip()]
        
        # Post-process tags: lowercase, remove duplicates, filter empty strings
        tags = list(dict.fromkeys([tag.lower() for tag in tags if tag]))
        
        # Limit to a maximum of 5 tags, even though we ask for 3-4.
        tags = tags[:5]
        
        if not tags:
            # st.warning is not thread-safe. The caller can log this.
            st.write(f"Warning: No valid tags generated for '{book_title}'. Using fallback tags.")
            return ["general", "book", "literature"]
        
        return tags
    except Exception as e:
        st.write(f"Error generating tags for '{book_title}': {str(e)}")
        return ["general", "book", "literature"]  # Fallback on error

def update_book_tags(conn):
    """Fetch all books, generate tags in parallel, and update the database in a single transaction."""
    try:
        with conn.session as s:
            result = s.execute(text("SELECT book_id, title FROM books WHERE title IS NOT NULL AND title != ''")).fetchall()
            if not result:
                st.warning("No books with titles found to process.")
                return 0, []

            books_to_process = result
            st.write(f"Found {len(books_to_process)} books to process.")
            
            updated_count = 0
            errors = []
            progress_text = "Generating tags... (This may take a while)"
            progress_bar = st.progress(0, text=progress_text)
            total_books = len(books_to_process)
            
            tagging_results = []
            # Use ThreadPoolExecutor for I/O-bound tasks (Ollama API calls)
            with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
                future_to_book = {executor.submit(generate_tags_with_ollama, book_title): (book_id, book_title) for book_id, book_title in books_to_process}
                
                for i, future in enumerate(concurrent.futures.as_completed(future_to_book)):
                    book_id, book_title = future_to_book[future]
                    try:
                        tags = future.result()
                        tagging_results.append((book_id, book_title, tags))
                    except Exception as exc:
                        error_msg = f"Book ID {book_id} ('{book_title}') generated an exception: {exc}"
                        errors.append(error_msg)
                    
                    progress_bar.progress((i + 1) / total_books, text=f"Generating tags... ({i + 1}/{total_books} books processed)")

            progress_bar.empty()
            
            if not tagging_results:
                st.warning("Tag generation completed, but no tags were successfully created.")
                if errors:
                    st.error("Errors encountered during tag generation:")
                    for err in errors:
                        st.write(err)
                return 0, errors

            st.write("Tag generation complete. Updating database...")
            update_progress = st.progress(0, text="Updating database...")
            
            # Stage all updates
            for i, (book_id, book_title, tags) in enumerate(tagging_results):
                tags_json = json.dumps(tags)
                try:
                    s.execute(
                        text("UPDATE books SET tags = :tags WHERE book_id = :book_id"),
                        {"tags": tags_json, "book_id": book_id}
                    )
                    updated_count += 1
                except Exception as db_error:
                    error_msg = f"Database error staging update for book ID {book_id} ('{book_title}'): {str(db_error)}"
                    errors.append(error_msg)
                    updated_count -=1 # Decrement if staging fails
                
                update_progress.progress((i + 1) / len(tagging_results), text=f"Staging database updates... ({i + 1}/{len(tagging_results)})")

            # Commit all staged updates in one transaction
            try:
                s.commit()
                st.success("Database commit successful.")
            except Exception as commit_error:
                st.error(f"Database commit failed: {commit_error}. Rolling back changes.")
                s.rollback()
                errors.append(f"Database commit failed: {commit_error}")
                updated_count = 0 # No books were actually updated if commit fails

            update_progress.empty()
            return updated_count, errors
    
    except Exception as e:
        st.error(f"An unexpected error occurred in update_book_tags: {str(e)}")
        return 0, [str(e)]

# Streamlit UI
st.write("#### Update Book Tags")


# Button to trigger tag update
if st.button("Generate and Save Tags"):
    try:
        # Test Ollama connection
        ollama.generate(model="llama3.1:8b", prompt="test")
        st.write("Ollama server is running.")
        
        # Update tags
        updated_count, errors = update_book_tags(conn)
        
        if updated_count > 0:
            st.success(f"Successfully updated tags for {updated_count} books.")
        else:
            st.warning("No books were updated.")
        
        if errors:
            st.error("Errors encountered during processing:")
            for err in errors:
                st.write(err)
    
    except Exception as e:
        st.error(f"Error: Ollama server not running or inaccessible: {str(e)}")
        st.markdown("Please start the Ollama server with `ollama serve` and ensure 'gemma3:1b' is installed.")


# ########################################################################################################################
# ##################################--------------- generate Subject for books ----------------------------######################
# #######################################################################################################################


# # Predefined list of educational subjects
# VALID_SUBJECTS = [
#     "Mathematics", "Physics", "Chemistry", "Biology", "Computer Science",
#     "History", "Geography", "Literature", "Economics", "Business Studies",
#     "Political Science", "Sociology", "Psychology", "Engineering", "Medicine",
#     "Education", "General Science", "Management", "Marketing", "Medical", "Self Help", 
#     "Physical Education", "Commerce", "Law", "Social Science"
# ]


# def find_closest_subject(suggested_subject):
#     """Map suggested subject to the closest predefined subject."""
#     if not suggested_subject:
#         return "General Science"
    
#     # Normalize and find closest match
#     suggested_subject = suggested_subject.strip().lower()
#     valid_subjects_lower = [s.lower() for s in VALID_SUBJECTS]
    
#     # Exact match
#     if suggested_subject in valid_subjects_lower:
#         return VALID_SUBJECTS[valid_subjects_lower.index(suggested_subject)]
    
#     # Find closest match using difflib
#     closest = difflib.get_close_matches(suggested_subject, valid_subjects_lower, n=1, cutoff=0.6)
#     if closest:
#         return VALID_SUBJECTS[valid_subjects_lower.index(closest[0])]
    
#     # Fallback
#     return "General Science"

# def generate_subject_with_ollama(book_title):
#     """Generate a single concise subject using the Ollama model."""
#     try:
#         prompt = f"""
#         You are a book categorization assistant. Based on the book title, suggest a single, concise subject that best describes the book's educational content. The subject must be one of the following: {', '.join(VALID_SUBJECTS)}. Return only the subject name with no additional text or formatting.

#         Book Title: {book_title}

#         Example output: Physics
#         """
#         response = ollama.generate(model="llama3.1:8b", prompt=prompt)
#         raw_response = response['response'].strip()
        
#         # Debug: Log raw response to console and Streamlit
#         st.write(f"Raw Ollama response for '{book_title}': {raw_response}")
        
#         # Clean and map to valid subject
#         subject = find_closest_subject(raw_response)
        
#         if subject == "General Science" and raw_response and raw_response.lower() not in [s.lower() for s in VALID_SUBJECTS]:
#             st.warning(f"No valid subject generated for '{book_title}'. Using fallback: General Science")
        
#         return subject
#     except Exception as e:
#         st.error(f"Error generating subject for '{book_title}': {str(e)}")
#         return "General Science"  # Fallback on error

# def update_book_subjects(conn):
#     """Fetch all books, generate a subject for each, and update the subject column."""
#     try:
#         with conn.session as s:
#             # Fetch all books (id and title)
#             result = s.execute(text("SELECT book_id, title FROM books")).fetchall()
#             if not result:
#                 st.warning("No books found in the database.")
#                 return 0, []
            
#             st.write(f"Found {len(result)} books to process.")
            
#             updated_count = 0
#             errors = []
#             progress_text = "Processing books and generating subjects..."
#             progress_bar = st.progress(0, text=progress_text)
#             total_books = len(result)
            
#             for i, (book_id, book_title) in enumerate(result):
#                 if not book_title:
#                     st.warning(f"Skipping book ID {book_id}: No title provided.")
#                     errors.append(f"Book ID {book_id}: No title provided.")
#                     continue
                
#                 # Generate subject
#                 subject = generate_subject_with_ollama(book_title)
                
#                 # Update the subject column
#                 try:
#                     update_result = s.execute(
#                         text("UPDATE books SET subject = :subject WHERE book_id = :book_id"),
#                         {"subject": subject, "book_id": book_id}
#                     )
#                     s.commit()
#                     updated_count += update_result.rowcount
#                     st.write(f"Updated book ID {book_id} ('{book_title}'): Subject = {subject}")
#                 except Exception as db_error:
#                     st.error(f"Database error updating book ID {book_id} ('{book_title}'): {str(db_error)}")
#                     s.rollback()
#                     errors.append(f"Book ID {book_id} ('{book_title}'): {str(db_error)}")
#                     continue
                
#                 # Update progress bar
#                 progress_value = min((i + 1) / total_books, 1.0)
#                 progress_bar.progress(progress_value, text=progress_text)
            
#             # Clear progress bar
#             progress_bar.empty()
#             return updated_count, errors
    
#     except Exception as e:
#         st.error(f"Error accessing database session: {str(e)}")
#         return 0, [str(e)]

# # Streamlit UI
# st.write("#### Update Book Subjects")

# # Connect to database
# conn = connect_db()

# # Ensure subject column exists
# try:
#     with conn.session as s:
#         result = s.execute(text("""
#             SHOW COLUMNS FROM books LIKE 'subject'
#         """)).fetchone()
        
#         if not result:  # column does not exist
#             s.execute(text("ALTER TABLE books ADD COLUMN subject TEXT"))
#             s.commit()

# except Exception as e:
#     st.error(f"Error ensuring subject column: {e}")
#     st.stop()

# # Button to trigger subject update
# if st.button("Generate and Save Subjects"):
#     with st.spinner("Processing books and generating subjects..."):
#         try:
#             # Test Ollama connection
#             ollama.generate(model="llama3.1:8b", prompt="test")
#             st.write("Ollama server is running.")
            
#             # Update subjects
#             updated_count, errors = update_book_subjects(conn)
            
#             if updated_count > 0:
#                 st.success(f"Successfully updated subjects for {updated_count} books.")
#             else:
#                 st.warning("No books were updated.")
            
#             if errors:
#                 st.error("Errors encountered during processing:")
#                 for err in errors:
#                     st.write(err)
        
#         except Exception as e:
#             st.error(f"Error: Ollama server not running or inaccessible: {str(e)}")
#             st.markdown("Please start the Ollama server with `ollama serve` and ensure 'gemma3:270m' is installed.")


# ########################################################################################################################
# ##################################--------------- See Subjects ----------------------------######################
# #######################################################################################################################


def filter_books_by_subject(conn, subject):
    """Fetch books matching the selected subject and return count."""
    try:
        with conn.session as s:
            # Query books by subject
            query = text("""
                SELECT book_id, title
                FROM books
                WHERE subject = :subject
            """)
            result = s.execute(query, {"subject": subject}).fetchall()
            
            # Get count of matching books
            count_query = text("SELECT COUNT(*) FROM books WHERE subject = :subject")
            count = s.execute(count_query, {"subject": subject}).scalar()
            
            return result, count
    except Exception as e:
        st.error(f"Error querying books: {str(e)}")
        return [], 0

# Streamlit UI
st.write("#### Filter Books by Subject")

# Connect to database
conn = connect_db()

# Subject filter
subject = st.selectbox(
    "Select Subject",
    ["All"] + VALID_SUBJECTS,
    index=0,
    key="subject_filter"
)

# Fetch and display books
if subject == "All":
    try:
        with conn.session as s:
            # Query all books
            query = text("SELECT book_id, title FROM books WHERE subject IS NOT NULL")
            result = s.execute(query).fetchall()
            count_query = text("SELECT COUNT(*) FROM books WHERE subject IS NOT NULL")
            count = s.execute(count_query).scalar()
    except Exception as e:
        st.error(f"Error querying all books: {str(e)}")
        result, count = [], 0
else:
    result, count = filter_books_by_subject(conn, subject)

# Display results
if result:
    st.write(f"**Total Books {count}**")
    st.dataframe(
        [{"Book ID": row.book_id, "Title": row.title} for row in result],
        width="stretch",
        hide_index=True
    )
else:
    st.warning(f"No books found for subject: {subject}")
    st.metric("Total Books", 0)